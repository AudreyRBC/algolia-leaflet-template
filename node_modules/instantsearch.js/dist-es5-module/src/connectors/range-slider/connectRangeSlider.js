'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = connectRangeSlider;

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _utils = require('../../lib/utils.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var usage = 'Usage:\nvar customRangeSlider = connectRangeSlider(function render(params, isFirstRendering) {\n  // params = {\n  //   refine,\n  //   range,\n  //   start,\n  //   format,\n  //   instantSearchInstance,\n  //   widgetParams,\n  // }\n});\nsearch.addWidget(\n  customRangeSlider({\n    attributeName,\n    [ min ],\n    [ max ],\n    [ precision = 2 ],\n  })\n);\nFull documentation available at https://community.algolia.com/instantsearch.js/connectors/connectRangeSlider.html\n';

/**
 * @typedef {Object} CustomRangeSliderWidgetOptions
 * @property {string} attributeName Name of the attribute for faceting.
 * @property {number} [min = undefined] Minimal slider value, default to automatically computed from the result set.
 * @property {number} [max = undefined] Maximal slider value, default to automatically computed from the result set.
 * @property {number} [precision = 2] Number of digits after decimal point to use.
 */

/**
 * @typedef {Object} RangeSliderRenderingOptions
 * @property {function({min: number, max: number})} refine Sets a range to filter the results on. Both values
 * are optional, and will default to the higher and lower bounds.
 * @property {{min: number, max: number}} numeric Results bounds without the current range filter.
 * @property {Array<number, number>} start Current numeric bounds of the search.
 * @property {{from: function, to: function}} formatter Transform for the rendering `from` and/or `to` values.
 * Both functions take a `number` as input and should output a `string`.
 * @property {Object} widgetParams All original `CustomRangeSliderWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * **RangeSlider** connector provides the logic to create custom widget that will let
 * the user refine results using a numeric range.
 *
 * Thic connectors provides a `refine()` function that accepts bounds. It will also provide
 * information about the min and max bounds for the current result set.
 * @type {Connector}
 * @param {function(RangeSliderRenderingOptions, boolean)} renderFn Rendering function for the custom **RangeSlider** widget.
 * @return {function(CustomRangeSliderWidgetOptions)} Re-usable widget factory for a custom **RangeSlider** widget.
 */
function connectRangeSlider(renderFn) {
  (0, _utils.checkRendering)(renderFn, usage);

  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attributeName = widgetParams.attributeName,
        userMin = widgetParams.min,
        userMax = widgetParams.max,
        _widgetParams$precisi = widgetParams.precision,
        precision = _widgetParams$precisi === undefined ? 2 : _widgetParams$precisi;


    if (!attributeName) {
      throw new Error(usage);
    }

    var formatToNumber = function formatToNumber(v) {
      return Number(Number(v).toFixed(precision));
    };

    var sliderFormatter = {
      from: function from(v) {
        return v;
      },
      to: function to(v) {
        return formatToNumber(v).toLocaleString();
      }
    };

    return {
      getConfiguration: function getConfiguration(originalConf) {
        var conf = {
          disjunctiveFacets: [attributeName]
        };

        var hasUserBounds = userMin !== undefined || userMax !== undefined;
        var boundsNotAlreadyDefined = !originalConf || originalConf.numericRefinements && originalConf.numericRefinements[attributeName] === undefined;

        if (hasUserBounds && boundsNotAlreadyDefined) {
          conf.numericRefinements = _defineProperty({}, attributeName, {});
          if (userMin !== undefined) conf.numericRefinements[attributeName]['>='] = [userMin];
          if (userMax !== undefined) conf.numericRefinements[attributeName]['<='] = [userMax];
        }

        return conf;
      },

      _getCurrentRefinement: function _getCurrentRefinement(helper) {
        var min = helper.state.getNumericRefinement(attributeName, '>=');
        var max = helper.state.getNumericRefinement(attributeName, '<=');

        if (min && min.length) {
          min = min[0];
        } else {
          min = -Infinity;
        }

        if (max && max.length) {
          max = max[0];
        } else {
          max = Infinity;
        }

        return {
          min: min,
          max: max
        };
      },
      init: function init(_ref) {
        var helper = _ref.helper,
            instantSearchInstance = _ref.instantSearchInstance;

        this._refine = function (bounds) {
          return function (newValues) {
            var currentValues = [helper.getNumericRefinement(attributeName, '>='), helper.getNumericRefinement(attributeName, '<=')];

            if (currentValues[0] !== newValues[0] || currentValues[1] !== newValues[1]) {
              helper.clearRefinements(attributeName);
              if (!bounds.min || newValues[0] > bounds.min) {
                helper.addNumericRefinement(attributeName, '>=', formatToNumber(newValues[0]));
              }
              if (!bounds.max || newValues[1] < bounds.max) {
                helper.addNumericRefinement(attributeName, '<=', formatToNumber(newValues[1]));
              }
              helper.search();
            }
          };
        };

        var stats = {
          min: userMin || null,
          max: userMax || null
        };
        var currentRefinement = this._getCurrentRefinement(helper);

        renderFn({
          refine: this._refine(stats),
          range: { min: Math.floor(stats.min), max: Math.ceil(stats.max) },
          start: [currentRefinement.min, currentRefinement.max],
          format: sliderFormatter,
          widgetParams: widgetParams,
          instantSearchInstance: instantSearchInstance
        }, true);
      },
      render: function render(_ref2) {
        var results = _ref2.results,
            helper = _ref2.helper,
            instantSearchInstance = _ref2.instantSearchInstance;

        var facetsFromResults = results.disjunctiveFacets || [];
        var facet = (0, _find2.default)(facetsFromResults, function (_ref3) {
          var name = _ref3.name;
          return name === attributeName;
        });
        var stats = facet !== undefined && facet.stats !== undefined ? facet.stats : {
          min: null,
          max: null
        };

        if (userMin !== undefined) stats.min = userMin;
        if (userMax !== undefined) stats.max = userMax;

        var currentRefinement = this._getCurrentRefinement(helper);

        renderFn({
          refine: this._refine(stats),
          range: { min: Math.floor(stats.min), max: Math.ceil(stats.max) },
          start: [currentRefinement.min, currentRefinement.max],
          format: sliderFormatter,
          widgetParams: widgetParams,
          instantSearchInstance: instantSearchInstance
        }, false);
      }
    };
  };
}